# Feature Contract: Min-Cut Graph Operations
# Defines what the product does

contract_meta:
  id: feature_mincut
  version: 1
  created_from_spec: "SPEC.md"
  covers_reqs:
    - FEAT-001
    - FEAT-002
    - FEAT-003
    - FEAT-004
    - FEAT-005
  owner: "product-team"

llm_policy:
  enforce: true
  llm_may_modify_non_negotiables: false

rules:
  non_negotiable:

    # FEAT-001: Chunk parsing
    - id: FEAT-001
      title: "Parse input into semantic chunks with unique IDs"
      scope:
        - "src/lib/parser/**/*.ts"
      behavior:
        required_patterns:
          - pattern: /chunk.*id|id.*chunk/i
            message: "Each chunk must have a unique ID"
          - pattern: /paragraph|bullet|sentence/i
            message: "Must handle paragraph, bullet, or sentence boundaries"
        example_compliant: |
          interface Chunk {
            id: string           // Unique identifier
            text: string         // Content
            sourceIndex: number  // Position in original
          }

          function parseToChunks(text: string): Chunk[] {
            // Split on paragraphs, bullets, or sentence groups
          }

    # FEAT-002: Embedding generation with caching
    - id: FEAT-002
      title: "Generate and cache embeddings via ruvector"
      scope:
        - "src/lib/embeddings/**/*.ts"
      behavior:
        required_patterns:
          - pattern: /ruvector|embedding.*cache/i
            message: "Must use ruvector for embedding storage"
          - pattern: /cosine|similarity|dot.*product/i
            message: "Must support similarity computation"
        example_compliant: |
          async function getChunkEmbeddings(
            chunks: Chunk[],
            memory: RuvectorMemory
          ): Promise<Map<string, number[]>> {
            const embeddings = new Map()
            for (const chunk of chunks) {
              const cached = await memory.get(`embed:${chunk.id}`)
              if (cached) {
                embeddings.set(chunk.id, cached)
              } else {
                const vec = await computeEmbedding(chunk.text)
                await memory.set(`embed:${chunk.id}`, vec)
                embeddings.set(chunk.id, vec)
              }
            }
            return embeddings
          }

    # FEAT-003: Similarity graph construction
    - id: FEAT-003
      title: "Build weighted similarity graph"
      scope:
        - "src/lib/graph/**/*.ts"
      behavior:
        required_patterns:
          - pattern: /edge.*weight|weight.*edge/i
            message: "Edges must have similarity weights"
          - pattern: /threshold|min.*similarity/i
            message: "Must filter edges by similarity threshold"
          - pattern: /cosine|similarity/i
            message: "Must use cosine similarity for edge weights"
        example_compliant: |
          interface Edge {
            source: string
            target: string
            weight: number  // Cosine similarity
          }

          function buildSimilarityGraph(
            embeddings: Map<string, number[]>,
            threshold: number = 0.3
          ): Graph {
            const edges: Edge[] = []
            for (const [id1, vec1] of embeddings) {
              for (const [id2, vec2] of embeddings) {
                if (id1 >= id2) continue
                const sim = cosineSimilarity(vec1, vec2)
                if (sim >= threshold) {
                  edges.push({ source: id1, target: id2, weight: sim })
                }
              }
            }
            return { nodes: [...embeddings.keys()], edges }
          }

    # FEAT-004: Min-cut algorithm
    - id: FEAT-004
      title: "Implement min-cut for N-way split"
      scope:
        - "src/lib/mincut/**/*.ts"
      behavior:
        required_patterns:
          - pattern: /minCut|min.*cut|stoer.*wagner|karger/i
            message: "Must implement a min-cut algorithm"
          - pattern: /partition|split|component/i
            message: "Must output partitions/components"
          - pattern: /cut.*edge|edge.*cut/i
            message: "Must identify cut edges (bleeding edges)"
        example_compliant: |
          interface MinCutResult {
            partitions: string[][]  // Node IDs grouped by partition
            cutEdges: Edge[]        // Edges that were cut
            cutWeight: number       // Total weight of cut edges
          }

          function minCutNWay(
            graph: Graph,
            n: number,
            seed: number
          ): MinCutResult {
            // Stoer-Wagner or recursive Karger's
          }

    # FEAT-005: Structured output
    - id: FEAT-005
      title: "Output workstreams with bleeding edges"
      scope:
        - "src/lib/output/**/*.ts"
        - "src/lib/workstream/**/*.ts"
      behavior:
        required_patterns:
          - pattern: /workstream|stream/i
            message: "Must output structured workstreams"
          - pattern: /bleed|cut.*edge|cross.*stream/i
            message: "Must identify bleeding/cross-stream edges"
        example_compliant: |
          interface Workstream {
            id: string
            chunks: Chunk[]
            bleedingEdges: {
              edge: Edge
              connectedTo: string  // Other workstream ID
            }[]
          }

          function formatOutput(
            chunks: Chunk[],
            result: MinCutResult
          ): Workstream[] {
            // Map partitions to workstreams with bleeding edges
          }

  soft:
    # FEAT-006: Visualization (optional)
    - id: FEAT-006
      title: "Graph visualization"
      suggestion: "Support ASCII or JSON export for visualization tools"
      llm_may_bend_if:
        - "MVP scope doesn't require visualization"

compliance_checklist:
  before_editing_files:
    - question: "Parsing text into chunks?"
      if_yes: "Ensure unique IDs and handle multiple boundary types (FEAT-001)"
    - question: "Working with embeddings?"
      if_yes: "Use ruvector caching (FEAT-002)"
    - question: "Building the graph?"
      if_yes: "Use weighted edges with similarity threshold (FEAT-003)"
    - question: "Implementing min-cut?"
      if_yes: "Return partitions AND cut edges (FEAT-004)"
    - question: "Formatting output?"
      if_yes: "Include bleeding edges per workstream (FEAT-005)"
